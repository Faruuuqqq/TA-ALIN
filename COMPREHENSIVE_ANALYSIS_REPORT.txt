================================================================================
COMPREHENSIVE CODEBASE ANALYSIS: CineMatch
Complete Code Redundancy, Bugs, and Quality Assessment
================================================================================

Generated: December 18, 2025
Project: CineMatch - Linear Algebra Movie Recommendation System
Scope: Full backend (cine-match-api) and frontend (cine-match-web) analysis

EXECUTIVE SUMMARY
=================
The CineMatch codebase demonstrates solid architectural patterns with good 
separation of concerns, but contains several areas for improvement:

- Code Quality: Generally good with some redundancy and code smell issues
- 3 Calculation Methods: Well-implemented and properly integrated across system
- Bugs: 5 identified issues (ranging from minor to moderate severity)
- Redundancies: 8 areas with duplicated or repetitive code
- Improvement Areas: 6 major refactoring opportunities

================================================================================
PART 1: THE 3 CALCULATION METHODS - DETAILED STRUCTURE
================================================================================

OVERVIEW
========
The recommendation system implements THREE DISTINCT SIMILARITY CALCULATION 
METHODS for vector-based movie matching.

METHOD 1: COSINE SIMILARITY (Default)
======================================
Mathematical Foundation:
  cos(θ) = (A · B) / (||A|| × ||B||)
  Result Range: [0, 1] (0 = orthogonal, 1 = identical)

Implementation Locations:
  - Backend: cine-match-api/src/math/linear-algebra.service.ts (lines 41-52)
  - Service Method: cosineSimilarity(vecA, vecB)

Code Structure:
  cosineSimilarity(vecA: number[], vecB: number[]): number {
    const dot = this.dotProduct(vecA, vecB);
    const magA = this.magnitude(vecA);
    const magB = this.magnitude(vecB);
    if (magA === 0 || magB === 0) return 0;
    return dot / (magA * magB);
  }

Calculation Steps:
  1. Compute dot product: Σ(A_i × B_i)
  2. Calculate magnitude A: √(Σ A_i²)
  3. Calculate magnitude B: √(Σ B_i²)
  4. Divide: dot / (magA × magB)

Integration Points:
  - similarity-calculator.service.ts line 48: Calls cosineSimilarity()
  - Frontend MathModal.tsx lines 66-71: Displays formula with KaTeX
  - Used in: recommend(), recommendByGenres(), recommendByTasteProfile(), 
    recommendByFusion()

METHOD 2: EUCLIDEAN DISTANCE (L2 Norm)
======================================
Mathematical Foundation:
  d(A, B) = √(Σ(A_i - B_i)²)
  Converted to Similarity: score = 1 / (1 + distance)
  Result Range: [0, 1] (smaller distance = higher similarity)

Implementation Locations:
  - Backend: cine-match-api/src/math/linear-algebra.service.ts (lines 59-66)
  - Service Method: euclideanDistance(vecA, vecB)

Code Structure:
  euclideanDistance(vecA: number[], vecB: number[]): number {
    let sum = 0;
    for (let i = 0; i < vecA.length; i++) {
      const diff = vecA[i] - vecB[i];
      sum += diff * diff;
    }
    return Math.sqrt(sum);
  }

Conversion to Similarity Score:
  In similarity-calculator.service.ts lines 54-58:
  const euclideanDist = this.mathService.euclideanDistance(vectorA, vectorB);
  score = 1 / (1 + euclideanDist);

Calculation Steps:
  1. For each dimension i: compute (A_i - B_i)²
  2. Sum all squared differences
  3. Take square root of sum
  4. Normalize using formula: 1 / (1 + distance)

Frontend Display:
  - MathModal.tsx lines 72-77: Displays formula and calculation

METHOD 3: MANHATTAN DISTANCE (L1 Norm)
======================================
Mathematical Foundation:
  d(A, B) = Σ|A_i - B_i|
  Converted to Similarity: score = 1 / (1 + distance)
  Result Range: [0, 1] (grid-based distance metric)

Implementation Locations:
  - Backend: cine-match-api/src/math/linear-algebra.service.ts (lines 73-79)
  - Service Method: manhattanDistance(vecA, vecB)

Code Structure:
  manhattanDistance(vecA: number[], vecB: number[]): number {
    let sum = 0;
    for (let i = 0; i < vecA.length; i++) {
      sum += Math.abs(vecA[i] - vecB[i]);
    }
    return sum;
  }

Conversion to Similarity Score:
  In similarity-calculator.service.ts lines 64-68:
  const manhattanDist = this.mathService.manhattanDistance(vectorA, vectorB);
  score = 1 / (1 + manhattanDist);

Calculation Steps:
  1. For each dimension i: compute |A_i - B_i|
  2. Sum all absolute differences
  3. Normalize using formula: 1 / (1 + distance)

Frontend Display:
  - MathModal.tsx lines 78-84: Displays formula and calculation

UNIFIED SIMILARITY CALCULATOR SERVICE
====================================
File: cine-match-api/src/recommendation/similarity-calculator.service.ts

Key Features:
  1. Single Dispatcher Pattern (lines 29-80):
     - Accepts metric parameter: 'cosine' | 'euclidean' | 'manhattan'
     - Routes to appropriate calculation method
     - Normalizes all results to [0, 1] range

  2. Batch Processing (lines 91-99):
     - calculateBatchSimilarity() for efficient bulk calculations
     - Used by recommendation service for multiple movie comparisons

  3. Validation (lines 104-132):
     - Vector dimension validation
     - Type checking
     - Empty vector handling

Integration Architecture:
  LinearAlgebraService (Math)
      ↓ (provides 3 calculation methods)
  SimilarityCalculatorService (Dispatcher & normalizer)
      ↓ (used by)
  RecommendationService (Business logic)
      ↓ (called by)
  AppController (REST endpoints)
      ↓ (exposed to)
  Frontend (React components)

METHOD COMPARISON TABLE
======================
Aspect          | Cosine        | Euclidean     | Manhattan
----------------|---------------|---------------|----------------
Formula         | dot/(||A||*||B|) | √Σ(A-B)²     | Σ|A-B|
Best For        | Angle matching | Straight-line | Grid paths
Sensitivity     | Direction      | Magnitude     | Component-wise
Computation     | Moderate       | Higher (sqrt) | Lowest
Use Case        | Default        | Precise       | Fast approx
Frontend        | Yes (KaTeX)    | Yes (KaTeX)   | Yes (KaTeX)

FRONTEND INTEGRATION FOR SIMILARITY METHODS
===========================================
Location: cine-match-web/src/components/MathModal.tsx

Visual Representation:
  1. Lines 28-58: Dynamic calculation of all three metrics
     - Computes real values based on movie & target vectors
     - Recalculates on metric selection change

  2. Lines 66-84: Formula rendering using KaTeX
     - LaTeX mathematical expressions
     - Metric-specific explanations

  3. Lines 200-264: Interactive vector component table
     - Shows dimension-by-dimension calculations
     - Highlights matching genres
     - Includes rating contribution

  4. Lines 268-284: Step-by-step calculation breakdown
     - Shows intermediate calculations
     - Final result highlighting

User Interaction:
  - Selectors in ControlsPanel.tsx (lines 204-219)
  - Available for: title search, mood search
  - Excluded from: fusion search (hardcoded to cosine)

================================================================================
PART 2: CODE REDUNDANCY ISSUES (8 IDENTIFIED)
================================================================================

REDUNDANCY #1: Duplicate Error Handling in Controllers
======================================================
Severity: MODERATE
Locations:
  - app.controller.ts lines 60-82 (getRecommendations)
  - app.controller.ts lines 132-155 (getRecommendationsByMood)
  - app.controller.ts lines 186-205 (getRecommendationsByTaste)
  - app.controller.ts lines 253-279 (getRecommendationsByFusion)

Pattern Repeated: 4 endpoints with ~25% duplicate error handling logic
Redundancy Impact: 80+ lines of duplicated error handling

Example:
  try {
    // ... validation ...
    const results = this.recommendationService.recommend(...);
    return { meta: {...}, data: results.map(...) };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes('tidak ditemukan')) {
      throw new BadRequestException({
        message: errorMessage,
        error: 'MOVIE_NOT_FOUND',
      });
  
